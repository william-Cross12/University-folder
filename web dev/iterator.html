<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Iterator Example</title>
</head>
<body>
  <div id="result"></div>

<script>
  function createDoubler() {
    let result = 1; // Initial value

    // Return an iterator object
    return {
      next: function() {
        result *= 2; // Double the previous result
        return {
          value: result,
          done: result > 1000
        };
      }
    };
  }

  // Create an iterator by calling createDoubler
  let iterator = createDoubler();

  // Use a for loop to traverse the iterator and display the results
  let output = '';
  for (let value = iterator.next().value; !iterator.next().done; value = iterator.next().value) {
    output += value + '<br>';
  }

  // Display the result in the HTML
  document.getElementById('result').innerHTML = output;
</script>

</body>
</html>



<!--An iterator in JavaScript is an object that provides 
    a way to access the elements of a collection one at a time, 
    allowing you to loop through the elements sequentially. It 
    implements the Iterator protocol, which consists of a next() 
    method that returns an object with properties like value (the 
    next value in the sequence) and done (a boolean indicating whether 
    the iteration is complete).-->


<!--
    Controlled Iteration:
An iterator provides explicit control over the iteration process with the next() method, allowing you to decide when and how to retrieve the next value.
State Preservation:
Iterators can maintain state between calls. In the example, the iterator remembers the current state (the doubled value) between calls, which can be useful for more complex scenarios.
Compatibility with for...of Loop:
Iterators are designed to work seamlessly with the for...of loop, making it easy to iterate over the elements of a sequence. This makes your code more readable and idiomatic.
Adherence to Iterator Protocol:
Using an iterator follows a standardized protocol ({ value, done }), making your code more predictable and aligning with JavaScript language conventions.
Dynamic Stopping Criteria:
Iterators allow for dynamic stopping criteria. In the example, the iterator stops when the value exceeds 1000, showcasing how you can implement custom conditions for iteration termination.
Compatibility with Other Iteration Functions:
Iterators can be easily integrated with other iteration functions provided by JavaScript, such as Array.from() or spread syntax (...), making them more versatile.
Encapsulation:
Iterators encapsulate the logic of iteration, keeping the internal state and implementation details hidden. This enhances the abstraction and modularity of your code.
-->